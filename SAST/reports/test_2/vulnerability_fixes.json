{
  "metadata": {
    "source_report": "/Users/izelikson/python/CryptoSlon/SAST/reports/second_test/vulnerability_snippets.json",
    "model": "gpt-5-mini",
    "template": "vulnerability_fix",
    "generated_at": "2025-08-24T00:00:00Z",
    "total_fixes": 5
  },
  "fixes": [
    {
      "vulnerability_info": {
        "type": "Improper Privilege Management (multiple endpoints)",
        "cwe": "CWE-269 Improper Privilege Management",
        "file": "/taskstate_copy/app.py",
        "location": "14-17",
        "severity": "HIGH"
      },
      "original_code": "   9         with app.app_context():\n  10             db.create_all()\n  11             app.logger.info('[INIT] [DB] [Succeess] DB create <%s>', app.config['SQLALCHEMY_DATABASE_URI'])\n  12             time.sleep(3)\n  13     \n  14 >>> if __name__ == '__main__':\n  15 >>>     with app.app_context():\n  16 >>>         db.create_all()\n  17 >>>         app.run()",
      "suggested_fix": "Внедрить строгую авторизацию на каждом защищённом действии (декораторы/мидлвары), принцип deny-by-default и проверку роли/владельца ресурса.",
      "llm_response": "import os\nimport ast\nimport hmac\nfrom functools import wraps\nfrom flask import request, jsonify\n\n# Загрузка сопоставления токен -> роль/информация из переменной окружения (пример: '{\"token1\": {\"role\":\"admin\",\"user_id\":1}, \"token2\":\"user\"}')\ntry:\n    ALLOWED_TOKENS = ast.literal_eval(os.getenv('ALLOWED_TOKENS', '{}'))\n    if not isinstance(ALLOWED_TOKENS, dict):\n        ALLOWED_TOKENS = {}\nexcept Exception:\n    ALLOWED_TOKENS = {}\n\ndef _get_auth_info():\n    auth_header = request.headers.get('Authorization', '')\n    if not auth_header.startswith('Bearer '):\n        return None\n    token = auth_header.split(None, 1)[1]\n    for allowed_token, info in ALLOWED_TOKENS.items():\n        try:\n            if hmac.compare_digest(str(allowed_token), str(token)):\n                if isinstance(info, dict):\n                    role = info.get('role')\n                    user_id = info.get('user_id')\n                else:\n                    role = info\n                    user_id = None\n                return {'token': token, 'role': role, 'user_id': user_id}\n        except Exception:\n            continue\n    return None\n\ndef public_route(f):\n    f.is_public = True\n    return f\n\ndef require_role(role):\n    def decorator(f):\n        @wraps(f)\n        def wrapper(*args, **kwargs):\n            return f(*args, **kwargs)\n        wrapper.required_role = role\n        return wrapper\n    return decorator\n\ndef owner_param(param_name):\n    def decorator(f):\n        @wraps(f)\n        def wrapper(*args, **kwargs):\n            return f(*args, **kwargs)\n        wrapper.owner_param = param_name\n        return wrapper\n    return decorator\n\n@app.before_request\ndef enforce_authorization():\n    view = app.view_functions.get(request.endpoint)\n    if not view:\n        return  # 404 or static resources — пусть Flask обработает\n    # Если явно публичный маршрут - пропускаем\n    if getattr(view, 'is_public', False):\n        return\n    auth = _get_auth_info()\n    if not auth:\n        return jsonify({'error': 'Unauthorized'}), 401\n    required_role = getattr(view, 'required_role', None)\n    if required_role and auth.get('role') != required_role:\n        return jsonify({'error': 'Forbidden'}), 403\n    owner_param_name = getattr(view, 'owner_param', None)\n    if owner_param_name:\n        # Собираем возможные источники параметра владельца\n        req_data = {}\n        if request.view_args:\n            req_data.update(request.view_args)\n        if request.args:\n            req_data.update(request.args.to_dict())\n        json_body = request.get_json(silent=True)\n        if json_body and isinstance(json_body, dict):\n            req_data.update(json_body)\n        owner_value = req_data.get(owner_param_name)\n        if owner_value is not None and str(owner_value) != str(auth.get('user_id')) and auth.get('role') != 'admin':\n            return jsonify({'error': 'Forbidden'}), 403\n    return\n\nif __name__ == '__main__':\n    # Безопасная и явная инициализация базы: разрешается только при ALLOW_DB_INIT=true и совпадении INIT_TOKEN с ADMIN_TOKEN\n    ALLOW_DB_INIT = os.getenv('ALLOW_DB_INIT', 'false').lower() == 'true'\n    INIT_TOKEN = os.getenv('INIT_TOKEN')\n    ADMIN_TOKEN = os.getenv('ADMIN_TOKEN')\n    if ALLOW_DB_INIT:\n        if not INIT_TOKEN or not ADMIN_TOKEN or not hmac.compare_digest(str(INIT_TOKEN), str(ADMIN_TOKEN)):\n            app.logger.warning('[SEC] DB initialization denied: missing or invalid INIT_TOKEN/ADMIN_TOKEN.')\n        else:\n            with app.app_context():\n                db.create_all()\n                app.logger.info('[INIT] [DB] [Success] DB created <%s>', app.config.get('SQLALCHEMY_DATABASE_URI'))\n    # Настройка секретов приложения через переменные окружения\n    app.secret_key = os.getenv('FLASK_SECRET_KEY', app.secret_key or os.urandom(24))\n    # Запуск приложения (хост/порт можно конфигурировать через переменные окружения)\n    host = os.getenv('FLASK_RUN_HOST', '0.0.0.0')\n    port = int(os.getenv('FLASK_RUN_PORT', '5000'))\n    debug = os.getenv('FLASK_DEBUG', 'false').lower() == 'true'\n    app.run(host=host, port=port, debug=debug)",
      "model_used": "gpt-5-mini"
    },
    {
      "vulnerability_info": {
        "type": "Improper Privilege Management (multiple endpoints)",
        "cwe": "CWE-269 Improper Privilege Management",
        "file": "/taskstate_copy/tsapp/func.py",
        "location": "29-31",
        "severity": "HIGH"
      },
      "original_code": "  24         if rid == 2:\n  25             res = True\n  26         if rid == 1:\n  27             if task.private == False or (task.uid1 == uid and task.private == True):\n  28                 res = True\n  29 >>>     if rid == 0:\n  30 >>>         if task.uid1 == uid:\n  31 >>>             res = True\n  32         return res\n  33     \n  34     \n  35     def jwt_encod(user):\n  36         jwt_data = {\"id\": user.id,\"login\": user.login}",
      "suggested_fix": "Внедрить строгую авторизацию на каждом защищённом действии (декораторы/мидлвары), принцип deny-by-default и проверку роли/владельца ресурса.",
      "llm_response": "def has_access(uid, rid, task):\n    \"\"\"\n    Strict authorization check (deny-by-default).\n    Roles:\n      - 2: admin (full access)\n      - 1: authenticated user (access to public tasks or own private tasks)\n      - 0: owner-only (access only if owner)\n    Returns True only when explicit conditions are met.\n    \"\"\"\n    # Validate role and uid types\n    try:\n        uid = int(uid)\n        rid = int(rid)\n    except (TypeError, ValueError):\n        return False\n\n    # Validate task object has expected attributes\n    if not hasattr(task, \"uid1\") or not hasattr(task, \"private\"):\n        return False\n\n    # Normalize task fields\n    try:\n        owner_uid = int(task.uid1)\n    except (TypeError, ValueError):\n        return False\n    private = bool(task.private)\n\n    ROLE_ADMIN = 2\n    ROLE_USER = 1\n    ROLE_OWNER = 0\n\n    # Deny by default\n    if rid == ROLE_ADMIN:\n        return True\n\n    if rid == ROLE_USER:\n        # Authenticated users: allow if task is public or they are the owner of a private task\n        if not private:\n            return True\n        return owner_uid == uid\n\n    if rid == ROLE_OWNER:\n        # Owner role: only allow if the user is the owner\n        return owner_uid == uid\n\n    # Unknown role -> deny\n    return False",
      "model_used": "gpt-5-mini"
    },
    {
      "vulnerability_info": {
        "type": "Weak Password Recovery Mechanism",
        "cwe": "CWE-640 Weak Password Recovery Mechanism for Forgotten Password",
        "file": "/taskstate_copy/tsapp/func.py",
        "location": "37-37",
        "severity": "HIGH"
      },
      "original_code": "  32         return res\n  33     \n  34     \n  35     def jwt_encod(user):\n  36         jwt_data = {\"id\": user.id,\"login\": user.login}\n  37 >>>     token = jwt.encode(jwt_data, JWT_KEY, algorithm=\"HS256\")\n  38         return token\n  39     \n  40     \n  41     def jwt_decod(token):\n  42         jwt_data = jwt.decode(token, JWT_KEY, algorithms=\"HS256\")",
      "suggested_fix": "Использовать криптостойкие одноразовые токены с истечением, привязкой к пользователю и каналу, проверять владение e-mail/2FA перед сбросом.",
      "llm_response": "import os\nimport time\nimport secrets\nfrom threading import Lock\nfrom hmac import compare_digest\n\nimport jwt\nfrom jwt import ExpiredSignatureError, InvalidTokenError\n\n_revoked_jti = set()\n_revoked_lock = Lock()\n\n\ndef _get_jwt_key():\n    key = os.environ.get(\"JWT_KEY\")\n    if not key:\n        raise RuntimeError(\"JWT_KEY environment variable is not set\")\n    return key\n\n\ndef jwt_encod(user, channel=\"email\", expires_in=3600):\n    if not hasattr(user, \"id\") or not hasattr(user, \"login\"):\n        raise ValueError(\"Invalid user object passed to jwt_encod\")\n\n    jwt_key = _get_jwt_key()\n\n    now = int(time.time())\n    jti = secrets.token_urlsafe(32)\n\n    jwt_data = {\n        \"sub\": str(user.id),               # subject: user id\n        \"login\": str(user.login),\n        \"purpose\": \"password_reset\",       # bind token to a specific purpose\n        \"channel\": channel,                # bind token to a delivery channel (e.g., email)\n        \"iat\": now,\n        \"exp\": now + int(expires_in),\n        \"jti\": jti,                        # one-time token identifier\n    }\n\n    token = jwt.encode(jwt_data, jwt_key, algorithm=\"HS256\")\n    return token\n\n\ndef _is_token_revoked(jti):\n    with _revoked_lock:\n        return jti in _revoked_jti\n\n\ndef _revoke_token(jti):\n    with _revoked_lock:\n        _revoked_jti.add(jti)\n\n\ndef jwt_decod(token, expected_channel=\"email\", revoke_after_use=True):\n    jwt_key = _get_jwt_key()\n\n    if not isinstance(token, str):\n        raise ValueError(\"Token must be a string\")\n\n    try:\n        jwt_data = jwt.decode(\n            token,\n            jwt_key,\n            algorithms=[\"HS256\"],\n            options={\"require\": [\"exp\", \"iat\", \"jti\", \"sub\"]},\n        )\n    except ExpiredSignatureError:\n        raise\n    except InvalidTokenError:\n        raise\n\n    # Validate purpose and channel binding\n    if jwt_data.get(\"purpose\") != \"password_reset\":\n        raise InvalidTokenError(\"Invalid token purpose\")\n    if not compare_digest(str(jwt_data.get(\"channel\", \"\")), str(expected_channel)):\n        raise InvalidTokenError(\"Token channel does not match expected channel\")\n\n    jti = jwt_data.get(\"jti\")\n    if not jti:\n        raise InvalidTokenError(\"Missing token identifier\")\n\n    if _is_token_revoked(jti):\n        raise InvalidTokenError(\"Token has already been used or revoked\")\n\n    if revoke_after_use:\n        _revoke_token(jti)\n\n    return jwt_data",
      "model_used": "gpt-5-mini"
    },
    {
      "vulnerability_info": {
        "type": "Hard-coded Secrets in sconfig.py",
        "cwe": "CWE-798 Use of Hard-coded Credentials",
        "file": "/taskstate_copy/tsapp/sconfig.py",
        "location": "3-3",
        "severity": "MEDIUM"
      },
      "original_code": "   1     import os\n   2     \n   3 >>> SECRET_KEY = 'CTF-2#SecretKey'\n   4     JWT_KEY = 'CTF-2#PirateLabel'\n   5     desteam = [\"External order\", \"Internal order\", \"Technical order\"]\n   6     tstatus = [\"ToDo\",\"Doing\", \"Done\"]\n   7     rteam = [\"Sailor\", \"Corsair\", \"Captain\"]\n   8     ",
      "suggested_fix": "Удалить секреты из репозитория, хранить в переменных окружения/secret manager, настроить ротацию и детекторы утечек.",
      "llm_response": "import os\n\ndef _get_required_secret(name: str, min_length: int = 32) -> str:\n    value = os.environ.get(name)\n    if not value:\n        raise RuntimeError(f\"Required environment variable '{name}' is not set.\")\n    if len(value) < min_length:\n        raise RuntimeError(f\"Environment variable '{name}' must be at least {min_length} characters long.\")\n    return value\n\nSECRET_KEY = _get_required_secret(\"SECRET_KEY\", min_length=32)\nJWT_KEY = _get_required_secret(\"JWT_KEY\", min_length=32)\n\ndesteam = [\"External order\", \"Internal order\", \"Technical order\"]\ntstatus = [\"ToDo\", \"Doing\", \"Done\"]\nrteam = [\"Sailor\", \"Corsair\", \"Captain\"]",
      "model_used": "gpt-5-mini"
    },
    {
      "vulnerability_info": {
        "type": "Hard-coded Secrets in sconfig.py",
        "cwe": "CWE-798 Use of Hard-coded Credentials",
        "file": "/taskstate_copy/tsapp/sconfig.py",
        "location": "4-4",
        "severity": "MEDIUM"
      },
      "original_code": "   1     import os\n   2     \n   3     SECRET_KEY = 'CTF-2#SecretKey'\n   4 >>> JWT_KEY = 'CTF-2#PirateLabel'\n   5     desteam = [\"External order\", \"Internal order\", \"Technical order\"]\n   6     tstatus = [\"ToDo\",\"Doing\", \"Done\"]\n   7     rteam = [\"Sailor\", \"Corsair\", \"Captain\"]\n   8     \n   9     ",
      "suggested_fix": "Удалить секреты из репозитория, хранить в переменных окружения/secret manager, настроить ротацию и детекторы утечек.",
      "llm_response": "import os\n\nSECRET_KEY = os.environ.get('SECRET_KEY')\nJWT_KEY = os.environ.get('JWT_KEY')\n\n# Validate presence and basic strength of secrets\n_MIN_SECRET_LENGTH = 32\nif not SECRET_KEY:\n    raise RuntimeError(\"Missing required environment variable: SECRET_KEY\")\nif not JWT_KEY:\n    raise RuntimeError(\"Missing required environment variable: JWT_KEY\")\nif len(SECRET_KEY) < _MIN_SECRET_LENGTH or len(JWT_KEY) < _MIN_SECRET_LENGTH:\n    raise RuntimeError(f\"SECRET_KEY and JWT_KEY must be at least {_MIN_SECRET_LENGTH} characters long\")\n\ndesteam = [\"External order\", \"Internal order\", \"Technical order\"]\ntstatus = [\"ToDo\", \"Doing\", \"Done\"]\nrteam = [\"Sailor\", \"Corsair\", \"Captain\"]",
      "model_used": "gpt-5-mini"
    }
  ]
}