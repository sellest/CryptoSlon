# Подход к проектированию

## Основные принципы
- Все потенциально переиспользуемые сущности реализуются как абстрактные классы (через abc.ABC).
- Абстрактные классы определяют контракт — набор обязательных методов и свойств, которые должны реализовать наследники.
- Конкретные реализации наследуются от абстрактных классов, тем самым обеспечивая единый интерфейс и возможность масштабирования.

### Почему абстрактные классы?

- Ясный контракт — любой разработчик видит, что нужно реализовать.
- Расширяемость — легко добавить новые реализации без переписывания ядра.
- Поддержка IDE — автодополнение и подсказки типов работают корректно.
- Соответствие принципу OCP (из SOLID) — система открыта для расширения, но закрыта для модификации.

### Рекомендации

- Использовать абстрактные классы только там, где действительно предполагаются несколько реализаций (агенты, инструменты, клиенты к LLM).
- Для одноразовых утилит (например, логгер или конфиг-лоадер) достаточно обычных классов или функций.
- Если новый модуль задуман как часть фреймворка, начинай с абстрактного класса и примера конкретной реализации.

Для переиспользуемых сущностей рекомендуется использовать следующий пайплайн:

Абстрактный класс -> конкретный экземпляр, построенный как обертка вокруг абстрактного класса -> простой скрипт helper 
для вызова экземпляра класса

## Соглашения о именовании
  - Абстрактные классы: `Base*` (BaseLLMClient, BaseTool)
  - Конкретные реализации: `*Client`, `*Tool`
  - Фабрики: `get_*`, `create_*`
  - Приватные методы: `_method_name`

# Примеры
Рассмотрим подход на примере инициализации LLM-Клиента

[BaseLLMClient](../LLMs/BaseLLMClient.py) - абстрактный класс, объявляющий методы, используемые в конкретных реализациях: 
```python
  @abstractmethod
    def _invoke(self, messages: List[Any]) -> str:
        """Низкоуровневый вызов модели."""
        raise NotImplementedError
```
В методе явно указано, что в качестве обязательного параметра метод принимает массив любых объектов 
и возвращает ответ модели в виде простой строки

Зная это, мы создаем контракт о том, что все LLM-Клиенты, созданные на основе этого метода, должны поддерживать такой ввод.

В каждом методе должен быть указан комментарий, который объясняет, зачем этот метод нужен. 

[GigaChatClient](../LLMs/GigaChatClient.py) - конкретный класс, вызвав который пользователь получает доступ к общению с 
GigaChat. Этот класс обогащает абстрактный _invoke конкретной реализацией
```python
    def _invoke(self, messages: List[RoleMsg]) -> str:
        lc_msgs = []
        for m in messages:
            role = (m.get("role") or "user").lower()
            content = m.get("content") or ""
            constructor = ROLE_MAP.get(role, HumanMessage)
            lc_msgs.append(constructor(content=content))

        resp = self.chat.invoke(lc_msgs)
        return getattr(resp, "content", str(resp))
```
В зависимости от степени переиспользуемости, в абстрактных классах можно написать методы, которые полностью работоспособны
во всех наследниках и достаточно лишь объявить наследуемый класс, но с нашим многообразием моделей лучше так не делать.

Для удобства вызова LLM-Клиентов написана функция помощник factory.py, которая позволяет инициализировать LLM-Клиент в 
вашем коде без вызова дополнительных зависимостей, импортов и прочего - очень чисто и удобно! 

```python
def get_llm_client(provider: str) -> BaseLLMClient:
    provider = provider.lower()
    if provider == "gigachat":
        return GigaChatClient()
    else:
        raise ValueError(f"Unknown LLM provider: {provider}")
```

Имея такую функцию, дальше в коде мы просто пишем
```python
from LLMs.factory import get_llm_client

gc = get_llm_client("gigachat")
```
И получаем готовый к использованию объект gc, содержащий нашего LLM-Клиента и все доступные ему методы. Удобно!

## Когда использовать паттерн "Абстракция → Реализация → Фабрика"
**Используйте когда:**
  - Планируется несколько реализаций (LLM-клиенты, агенты)
  - Нужна взаимозаменяемость компонентов
  - Система должна быть расширяемой

**Избегайте когда:**
  - Только одна реализация и не планируется расширение
  - Простые утилиты (логгеры, парсеры конфигов)


В конце, хочу обобщить, что если мы создаем переиспользуемую сущность - LLM-Клиент, агента, тулзу, то мы следуем
следующему пайплайну: 
Абстрактный класс -> Конкретный класс -> функция-помощник.

Первым и третьим шагом можно пренебречь, если класс очень специфичен или его вызов очень прост, оставляю это на совесть 
читателя.

# Обработка ошибок и логирование

## Принципы логирования

### Структура логгеров:
- Каждый класс должен иметь свой логгер: `self.logger = logging.getLogger(f"{self.__class__.__name__}")`
- Агенты используют иерархию: `logging.getLogger(f"agent.{agent_name}")`
- Инструменты: `logging.getLogger(f"tool.{self.name}")`

### Уровни логирования:
- **DEBUG**: Детальная информация для отладки (параметры вызовов, промежуточные результаты)
- **INFO**: Ключевые события (начало операции, успешное выполнение)
- **WARNING**: Проблемы, не критичные для работы (fallback к запасному провайдеру)
- **ERROR**: Ошибки, которые нарушают работу функции

### Примеры использования:
```python
class BaseAgent:
    def __init__(self, agent_name: str):
        self.logger = logging.getLogger(f"agent.{agent_name}")
        self.logger.info(f"Agent '{agent_name}' initialized")
    
    def process_request(self, user_input: str):
        self.logger.info(f"Processing request: {user_input[:50]}...")
        try:
            response = self._execute_logic(user_input)
            self.logger.info("Request processed successfully")
            return response
        except Exception as e:
            self.logger.error(f"Request processing failed: {e}")
            raise
```


# Принципы тестирования решений
  - Тестируйте ваши решения через mock-реализации в разделе `tests/`

